@page "/en/latest/configuration/scripts"
@{
    Layout = "_ArticleLayout";
    ViewBag.Title = "Scripts and Formulas";
}

<nav class="doc-toc">
    <div class="h6">On this page</div>
    <hr>
    <ul>
        <li><a href="#script-rules">Script Creation Rules</a></li>
        <li><a href="#available-variables">Available Variables</a></li>
        <li><a href="#available-functions">Available Functions</a></li>
        <li><a href="#template-functions">Functions from Project Template</a></li>
        <li><a href="#debugging">Debugging Scripts</a></li>
        <li><a href="#examples">Examples of Formulas</a></li>
    </ul>
</nav>

<div class="doc-content">
    <h1>Scripts and Formulas</h1>
    <p>В приложение Сервер встроен механизм исполнения пользовательских скриптов. Скрипты применяются для расчёта значений и статусов каналов, а также для расчёта значений команд управления.</p>
    <p>Скрипты записываются в таблицу <strong>Скрипты</strong> базы конфигурации. Созданный по шаблону проект уже содержит начальный набор скриптов, который удобно использовать в качестве примеров для разработки собственных скриптов. Переменные и функции, реализованные в таблице <strong>Скрипты</strong>, затем вызываются в столбцах <strong>Входная формула</strong> и <strong>Выходная формула</strong> таблицы <strong>Каналы</strong> . Чтобы расчёт по формуле для какого-либо канала выполнялся, необходимо установить для него галочку в столбце <strong>Формула вкл</strong>.</p>

    <h2 id="script-rules">Script Creation Rules</h2>
    <p>Общие правила написания и использования скриптов:</p>
    <ol>
        <li>Скрипты записываются согласно <a href="https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/" target="_blank">синтаксису языка C#</a>. Доступны различные классы фреймворка .NET, например, Math, DateTime, File.</li>
        <li>В таблицу <strong>Скрипты</strong> добавляются новые константы, поля, свойства и методы, которые становятся доступны в формулах каналов.</li>
        <li>Если хотя бы один скрипт или формула содержит ошибку, работа Сервера невозможна. Информация об ошибках в скриптах выводится в журнал приложения.</li>
    </ol>

    <p>Правила вычисления формул каналов:</p>
    <ol>
        <li>Расчёт входной формулы для каналов типа <em>Входной</em> и <em>Входной/выходной</em> выполняется только при получении Сервером новых данных по этим каналам. Используйте эти типы каналов, если данные приходят от устройств.</li>
        <li>Расчёт входной формулы для каналов типа <em>Расчётный</em> и <em>Расчётный/выходной</em> выполняется постоянно на каждом шаге основного цикла Сервера. Последовательность расчёта – от меньших номеров каналов к большим. Расчётные типы каналов используются, если значение и статус канала вычисляются на основе данных других каналов.</li>
        <li>Расчёт выходной формулы для каналов типа <em>Входной/выходной</em>, <em>Расчётный/выходной</em> и <em>Выходной</em> выполняется при отправке команды управления на соответствующий канал.</li>
        <li>Статус канала после вычисления входной формулы для каналов типа <em>Входной</em> и <em>Входной/выходной</em> равен статусу переданных Серверу данных, если расчёт статуса не задан в формуле явно.</li>
        <li>Для каналов типа <em>Расчётный</em> и <em>Расчётный/выходной</em> устанавливается статус <em>Определён</em>, если расчёт статуса не задан в формуле явно.</li>
        <li>Если входная формула канала содержит символ &quot;;&quot;, то она разбивается на две части: первая часть рассчитывает значение канала, вторая часть – статус канала.</li>
        <li>Если для канала заданы границы, то статус канала пересчитывается с учётом границ после вычисления входной формулы канала.</li>
        <li>Формулы должны возвращать значения опередённых типов данных, которые описаны ниже.</li>
    </ol>

    <p>Входные формулы каналов возвращают данные следующих типов:</p>
    <table class="table table-hover">
        <thead>
            <tr>
                <th>Data Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>double</td>
                <td>Значение канала</td>
            </tr>
            <tr>
                <td>CnlData</td>
                <td>Значение и статус канала</td>
            </tr>
            <tr>
                <td>long</td>
                <td>64-битное целое значение канала, для которого в таблице <strong>Каналы</strong> установлен тип данных <em>Integer</em></td>
            </tr>
            <tr>
                <td>string</td>
                <td>Строковое значение канала, для которого в таблице <strong>Каналы</strong> установлен тип данных <em>ASCII string</em> или <em>Unicode string</em></td>
            </tr>
        </tbody>
    </table>
    <p>Если входная формула канала возвращает другой тип данных, не указанный таблице, возвращаемое формулой значение приводится к соответствующему типу в зависимости от типа данных канала. Часть входной формулы канала, которая рассчитвает статус канала, должна возвращать целое число типа <em>int</em>.</p>

    <p>Выходные формулы каналов возвращают данные следующих типов:</p>
    <table class="table table-hover">
        <thead>
            <tr>
                <th>Data Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>double</td>
                <td>Значение команды. Чтобы отменить команду, формула должна вернуть <code>double.NaN</code></td>
            </tr>
            <tr>
                <td>CnlData</td>
                <td>Значение команды. Чтобы отменить команду, формула должна вернуть <code>CnlData.Empty</code></td>
            </tr>
            <tr>
                <td>byte[]</td>
                <td>Бинарные данные команды. Чтобы отменить команду, формула должна вернуть <code>null</code></td>
            </tr>
            <tr>
                <td>string</td>
                <td>Строковые данные команды. Преобразуются Сервером в массив байт</td>
            </tr>
        </tbody>
    </table>

    <h2 id="available-variables">Available Variables</h2>
    <p>The scripting engine provides the following built-in variables:</p>
    <table class="table table-hover">
        <thead>
            <tr>
                <th>Variable</th>
                <th>Data Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Timestamp</td>
                <td>DateTime</td>
                <td>Timestamp of the processed data (UTC)</td>
            </tr>
            <tr>
                <td>IsCurrent</td>
                <td>bool</td>
                <td>Processed data is current data</td>
            </tr>
            <tr>
                <td>CnlNum</td>
                <td>int</td>
                <td>Channel number for which the formula is calculated</td>
            </tr>
            <tr>
                <td>Channel</td>
                <td>Cnl</td>
                <td>Properties of the channel for which the formula is calculated</td>
            </tr>
            <tr>
                <td>ArrIdx</td>
                <td>int</td>
                <td>Index of the processed array element</td>
            </tr>
            <tr>
                <td>Cnl, CnlVal</td>
                <td>double</td>
                <td>Channel value transmitted to Server before the calculation</td>
            </tr>
            <tr>
                <td>CnlStat</td>
                <td>int</td>
                <td>Channel status transmitted to Server before the calculation</td>
            </tr>
            <tr>
                <td>CnlData</td>
                <td>CnlData</td>
                <td>Channel data transmitted to Server before the calculation</td>
            </tr>
            <tr>
                <td>Cmd, CmdVal</td>
                <td>double</td>
                <td>Command value transmitted to Server before the calculation</td>
            </tr>
            <tr>
                <td>CmdData</td>
                <td>byte[]</td>
                <td>Command data transmitted to Server</td>
            </tr>
            <tr>
                <td>CmdDataStr</td>
                <td>string</td>
                <td>Command data as a string</td>
            </tr>
        </tbody>
    </table>

    <h2 id="available-functions">Available Functions</h2>
    <p>The scripting engine provides the following built-in functions:</p>
    <table class="table table-hover">
        <thead>
            <tr>
                <th>Function</th>
                <th>Data Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>N(n)</td>
                <td>int</td>
                <td>Returns the channel number n. Used in channel cloning</td>
            </tr>
            <tr>
                <td>Val()</td>
                <td>double</td>
                <td>Actual value of the formula channel</td>
            </tr>
            <tr>
                <td>Val(n)</td>
                <td>double</td>
                <td>Actual value of the channel n</td>
            </tr>
            <tr>
                <td>SetVal(n, val)</td>
                <td>double</td>
                <td>Sets the current value of the channel n</td>
            </tr>
            <tr>
                <td>Stat()</td>
                <td>int</td>
                <td>Actual status of the formula channel</td>
            </tr>
            <tr>
                <td>Stat(n)</td>
                <td>int</td>
                <td>Actual status of the channel n</td>
            </tr>
            <tr>
                <td>SetStat(n, stat)</td>
                <td>int</td>
                <td>Sets the current status of the channel n</td>
            </tr>
            <tr>
                <td>Data()</td>
                <td>CnlData</td>
                <td>Actual data of the formula channel</td>
            </tr>
            <tr>
                <td>Data(n)</td>
                <td>CnlData</td>
                <td>Actual data of the channel n</td>
            </tr>
            <tr>
                <td>SetData(n, val, stat)</td>
                <td>double</td>
                <td>Sets the current value and status of the channel n</td>
            </tr>
            <tr>
                <td>SetData(n, cnlData)</td>
                <td>double</td>
                <td>Sets the current data of the channel n</td>
            </tr>
            <tr>
                <td>NewData(val, stat)</td>
                <td>CnlData</td>
                <td>Creates a new channel data instance</td>
            </tr>
            <tr>
                <td>PrevVal()</td>
                <td>double</td>
                <td>Previous value of the formula channel</td>
            </tr>
            <tr>
                <td>PrevVal(n)</td>
                <td>double</td>
                <td>Previous value of the channel n</td>
            </tr>
            <tr>
                <td>PrevStat()</td>
                <td>int</td>
                <td>Previous status of the formula channel</td>
            </tr>
            <tr>
                <td>PrevStat(n)</td>
                <td>int</td>
                <td>Previous status of the channel n</td>
            </tr>
            <tr>
                <td>PrevData()</td>
                <td>CnlData</td>
                <td>Previous data of the formula channel</td>
            </tr>
            <tr>
                <td>PrevData(n)</td>
                <td>CnlData</td>
                <td>Previous data of the channel n</td>
            </tr>
            <tr>
                <td>Time()</td>
                <td>DateTime</td>
                <td>Actual timestamp of the formula channel</td>
            </tr>
            <tr>
                <td>Time(n)</td>
                <td>DateTime</td>
                <td>Actual timestamp of the channel n</td>
            </tr>
            <tr>
                <td>PrevTime()</td>
                <td>DateTime</td>
                <td>Previous timestamp of the formula channel</td>
            </tr>
            <tr>
                <td>PrevTime(n)</td>
                <td>DateTime</td>
                <td>Previous timestamp of the channel n</td>
            </tr>
            <tr>
                <td>Deriv(n)</td>
                <td>double</td>
                <td>Time derivative of the channel n</td>
            </tr>
        </tbody>
    </table>

    <h2 id="template-functions">Functions from Project Template</h2>
    <p>In a project that was created based on a standard template, the <strong>Scripts</strong> table contains the following functions:</p>
    <table class="table table-hover">
        <thead>
            <tr>
                <th>Function</th>
                <th>Data Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GetBit(val, n)</td>
                <td>double</td>
                <td>Returns the n-th bit of the specified value</td>
            </tr>
            <tr>
                <td>GetBit(cnlData, val)</td>
                <td>CnlData</td>
                <td>Returns a channel data consists of the n-th bit of the value and the channel status</td>
            </tr>
            <tr>
                <td>SetBit(val, n, isOn)</td>
                <td>double</td>
                <td>Sets the n-th bit of the specified value</td>
            </tr>
            <tr>
                <td>SetBit(cnlData, n, isOn)</td>
                <td>CnlData</td>
                <td>Sets the n-th bit of the channel value, keeping the channel status unchanged</td>
            </tr>
            <tr>
                <td>GetByte(val, n)</td>
                <td>double</td>
                <td>Returns the n-th byte of the specified value</td>
            </tr>
            <tr>
                <td>DataRel(offset)</td>
                <td>CnlData</td>
                <td>Channel data relative to the current channel</td>
            </tr>
            <tr>
                <td>SetData()</td>
                <td>double</td>
                <td>Sets the current channel data according to the command value</td>
            </tr>
            <tr>
                <td>Now()</td>
                <td>double</td>
                <td>The current date and time as a floating-point number. Uses the server time zone</td>
            </tr>
            <tr>
                <td>UtcNow()</td>
                <td>double</td>
                <td>The current date and time as a floating-point number. Uses universal time zone (UTC)</td>
            </tr>
            <tr>
                <td>UnixTime()</td>
                <td>long</td>
                <td>The current Unix time in seconds</td>
            </tr>
            <tr>
                <td>EncodeDate(<wbr />dateTime)</td>
                <td>double</td>
                <td>Converts the specified date and time to a channel value of Double type</td>
            </tr>
            <tr>
                <td>DecodeDate(val)</td>
                <td>DateTime</td>
                <td>Converts the channel value to a date and time</td>
            </tr>
            <tr>
                <td>EncodeAscii(s)</td>
                <td>double</td>
                <td>Converts an ASCII string, up to 8 characters long, to a floating point number</td>
            </tr>
            <tr>
                <td>EncodeUnicode(s)</td>
                <td>double</td>
                <td>Converts a Unicode string, up to 4 characters long, to a floating point number</td>
            </tr>
            <tr>
                <td>DecodeAscii(val)</td>
                <td>string</td>
                <td>Converts the specified value to an ASCII string up to 8 characters long</td>
            </tr>
            <tr>
                <td>DecodeUnicode(<wbr />val)</td>
                <td>string</td>
                <td>Converts the specified value to an Unicode string up to 4 characters long</td>
            </tr>
            <tr>
                <td>Substring(s, startIndex, length)</td>
                <td>string</td>
                <td>Extracts a substring from the string with bounds checking</td>
            </tr>
            <tr>
                <td>SplitAscii(<wbr />getStringFunc)</td>
                <td>string</td>
                <td>Splits an ASCII string to store by several channels</td>
            </tr>
            <tr>
                <td>SplitUnicode(<wbr />getStringFunc)</td>
                <td>string</td>
                <td>Splits an Unicode string to store by several channels</td>
            </tr>
            <tr>
                <td>EverySec(<wbr />getDataFunc)</td>
                <td>CnlData</td>
                <td>Executes the specified function every second</td>
            </tr>
            <tr>
                <td>EveryMin(<wbr />getDataFunc)</td>
                <td>CnlData</td>
                <td>Executes the specified function every minute</td>
            </tr>
            <tr>
                <td>EveryHour(<wbr />getDataFunc)</td>
                <td>CnlData</td>
                <td>Executes the specified function every hour</td>
            </tr>
            <tr>
                <td>CountPulse(<wbr />cnlNum)</td>
                <td>double</td>
                <td>Counts a pulse of the specified channel</td>
            </tr>
            <tr>
                <td>HourStarted()</td>
                <td>bool</td>
                <td>Indicates that a new hour has started. The result is true once for each channel</td>
            </tr>
            <tr>
                <td>DayStarted()</td>
                <td>bool</td>
                <td>Indicates that a new day has started. The result is true once for each channel</td>
            </tr>
            <tr>
                <td>MonthStarted()</td>
                <td>bool</td>
                <td>Indicates that a new month has started. The result is true once for each channel</td>
            </tr>
        </tbody>
    </table>

    <p>Additional scripts, including those for calculating averages, are available on <a href="https://github.com/RapidScada/scada-community/tree/master/Formulas" target="_blank">GitHub</a>.</p>

    <h2 id="debugging">Debugging Scripts</h2>
    <p>When developing your own scripts, follow the syntax rules and check that the scripts work correctly. If the Server service failed to compile scripts at startup, error information is displayed in the Server operation log <code>ScadaServer.log</code>, and the compiled source code is available in the <code>CalcEngine.cs</code> file, which is located in the Server log directory. To develop complex formulas, we recommend using Microsoft Visual Studio or Visual Studio Code.</p>

    <h2 id="examples">Examples of Formulas</h2>
    <p>Example 1: Linear transformation of a channel value received from a device. The formula is used for a channel of the <em>Input</em> type.</p>
    <pre><code>10 * Cnl + 1</code></pre>

    <p>Example 2: The sum of the values of channels 101 and 102. The status is extracted from channel 101. The formula is used for a channel of the <em>Calculated</em> type.</p>
    <pre><code>Val(101) + Val(102); Stat(101)</code></pre>

    <p>Example 3: The formula that is used for a channel of calculation type extracts the 0<sup>th</sup> bit from the data of channel 105.</p>
    <pre><code>GetBit(Data(105), 0)</code></pre>

    <p>Example 4: The formula increments the counter by one every minute, resetting the counter at the beginning of each hour.</p>
    <pre><code>EveryMin(() => HourStarted() ? 0 : Val() + 1)</code></pre>
</div>
